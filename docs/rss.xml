<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Blog</title><link>https://blog.cpuck.com</link><description>Description</description><copyright>Blog</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://github.githubassets.com/favicons/favicon.svg</url><title>avatar</title><link>https://blog.cpuck.com</link></image><lastBuildDate>Sun, 20 Jul 2025 04:47:12 +0000</lastBuildDate><managingEditor>Blog</managingEditor><ttl>60</ttl><webMaster>Blog</webMaster><item><title>导出docx文档里的图像</title><link>https://blog.cpuck.com/post/dao-chu-docx-wen-dang-li-de-tu-xiang.html</link><description>## 执行结果
```
f:/doc/
│
├── document1.docx
├── document2.docx
└── document3.docx
```

```
f:/doc/png/
│
├── document1/
│   ├── document1.txt      # Contains the extracted text (e.g., '图片简介：description text')
│   ├── document1_000001.png  # Image extracted from the document, renamed based on the corresponding text
│   ├── document1_000002.png  # Another image
│   └── document1_000003.png  # Another image
│
├── document2/
│   ├── document2.txt
│   ├── document2_000001.png
│   ├── document2_000002.png
│   └── document2_000003.png
│
└── document3/
    ├── document3.txt
    ├── document3_000001.png
    ├── document3_000002.png
    └── document3_000003.png
```


##  完整代码
```
from docx import Document
import os
import re
import shutil
 
# pip install python-docx
# pip install lxml  # 通常不必需，除非在安装 python-docx 后出现问题
 
 
def get_picture(document, paragraph):
    '''
    从段落中获取图片
    '''
    img = paragraph._element.xpath('.//pic:pic')
    if not img:
        return None
    img = img[0]
    embed = img.xpath('.//a:blip/@r:embed')[0]
    related_part = document.part.related_parts[embed]
    image = related_part.image
    return image
 
def extract_content(docx_path, output_dir):
    try:
        doc = Document(docx_path)
        base_filename = os.path.splitext(os.path.basename(docx_path))[0]
        doc_output_dir = os.path.join(output_dir, base_filename)
        os.makedirs(doc_output_dir, exist_ok=True)
        shutil.copy(docx_path, doc_output_dir)
 
        extracted_text = []
        extracted_images = []
 
        for para in doc.paragraphs:
            match = re.search(r'图片简介：(.*)', para.text)
            if match:
                violation_text = match.group(1).strip() if match.group(1).strip() else 'XXX'
                extracted_text.append(violation_text)
 
            image = get_picture(doc, para)
            if image:
                blob = image.blob
                image_index = len(extracted_images) + 1
                formatted_index = f'{image_index:06d}'
                img_path = os.path.join(doc_output_dir, f'{base_filename}_{formatted_index}.png')
                extracted_images.append(img_path)
                with open(img_path, 'wb') as f:
                    f.write(blob)
 
        if extracted_text:
            text_filename = f'{base_filename}.txt'
            text_path = os.path.join(doc_output_dir, text_filename)
            with open(text_path, 'w', encoding='utf-8') as text_file:
                text_file.write('\n'.join(extracted_text))
            rename_images_based_on_text(doc_output_dir, text_path, extracted_images)
 
    except Exception as e:
        print(f'Error processing {docx_path}: {e}')
 
def rename_images_based_on_text(output_dir, text_file_path, extracted_images):
    with open(text_file_path, 'r', encoding='utf-8') as file:
        lines = file.readlines()
 
    if len(extracted_images) != len(lines):
        print(f'Error: The number of images ({len(extracted_images)}) and text lines ({len(lines)}) do not match in {output_dir}.')
        return
 
    for image_path, line in zip(extracted_images, lines):
        new_image_name = f'{os.path.splitext(image_path)[0]}_{line.strip()}{os.path.splitext(image_path)[1]}'
        os.rename(image_path, new_image_name)
        print(f'Renamed '{image_path}' to '{new_image_name}'')
 
def process_documents(folder_path, output_folder):
    if not os.path.exists(output_folder):
        os.makedirs(output_folder)
    for filename in os.listdir(folder_path):
        if filename.endswith('.docx') or filename.endswith('.doc'):
            docx_path = os.path.join(folder_path, filename)
            extract_content(docx_path, output_folder)
 
# 示例用法
folder_path = 'f:/doc'
output_folder = 'f:/doc/png'
process_documents(folder_path, output_folder)
```。</description><guid isPermaLink="true">https://blog.cpuck.com/post/dao-chu-docx-wen-dang-li-de-tu-xiang.html</guid><pubDate>Sun, 20 Jul 2025 04:46:40 +0000</pubDate></item><item><title>获取网页链接</title><link>https://blog.cpuck.com/post/huo-qu-wang-ye-lian-jie.html</link><description>控制台浏览器获取网址
```
const links = document.getElementsByTagName('a');
// 遍历所有链接并查找匹配的网址
for (const link of links) {
  const href = link.href;
  // 使用正则表达式匹配类似的网址
  const urlRegex = /https:\/\/www\.bilibili\.com\/video\/[A-Za-z0-9]+\/?/;
  if (urlRegex.test(href)) {
    console.log('匹配到的网址: ' + href);
  }
}
```。</description><guid isPermaLink="true">https://blog.cpuck.com/post/huo-qu-wang-ye-lian-jie.html</guid><pubDate>Sun, 20 Jul 2025 04:45:35 +0000</pubDate></item><item><title>查找替换</title><link>https://blog.cpuck.com/post/cha-zhao-ti-huan.html</link><description>搜索匹配当前目录下所有[文件名]或文件里的内容打印显示行号
```
grep -rn 'Money' *
```

搜索多个文件并查找匹配文本在哪些文件中：
```
grep -l 'Money' file1 file2 file3...
```

查找 formatting.php 文件内 length’, 55 替换 length’, 56 :
```
sed -i s/'length', 55'/'length', 56'/g `grep 'length', 55' -rl --include='formatting.php' ./`
```。</description><guid isPermaLink="true">https://blog.cpuck.com/post/cha-zhao-ti-huan.html</guid><pubDate>Sun, 20 Jul 2025 04:45:05 +0000</pubDate></item><item><title>移到文件</title><link>https://blog.cpuck.com/post/yi-dao-wen-jian.html</link><description>### 按照指定文件名移到文件

### 简介
假设目录与文件如下：
```
H:\
├─ data
│   ├─ report1.txt
│   ├─ image_fail.png
│   └─ sub
│       └─ test_error.log
├─ list.txt
└─ copy    （初始为空）
```

list.txt 内容（每行一个关键字）
```
report
fail
missing
error
```

运行控制台输出：
```
✔ 已移动: 'report1.txt' 对应关键字 'report' 到 'H:\copy\report1.txt'
✔ 已移动: 'image_fail.png' 对应关键字 'fail' 到 'H:\copy\image_fail.png'
⚠ 未找到匹配文件 for key: 'missing'
✔ 已移动: 'test_error.log' 对应关键字 'error' 到 'H:\copy\test_error.log'
 
共 4 个关键字，成功移动 3 个，对应文件。</description><guid isPermaLink="true">https://blog.cpuck.com/post/yi-dao-wen-jian.html</guid><pubDate>Sun, 20 Jul 2025 04:44:19 +0000</pubDate></item><item><title>删除重复图像</title><link>https://blog.cpuck.com/post/shan-chu-zhong-fu-tu-xiang.html</link><description>```
import os
import cv2
import numpy as np
from keras.applications.resnet50 import ResNet50, preprocess_input
 
# pip install opencv-python numpy keras tensorflow
 
def extract_image_features(image_path):
    image = cv2.imread(image_path)  # 读取图片
    image = cv2.resize(image, (256, 256))  # 缩放图片到统一尺寸
    image = image[16:240, 16:240]  # 裁剪中间区域(224x224)
    
    image = np.expand_dims(image, axis=0)  # 扩展维度以匹配模型输入要求
    image = preprocess_input(image)  # 预处理图片
    
    features = model.predict(image)  # 提取特征向量
    features /= np.linalg.norm(features)  # 归一化特征向量
    
    return features.flatten()  # 平铺特征向量
 
def delete_duplicate_images():
    current_dir = os.getcwd()  # 获取当前目录路径
    files = [f for f in os.listdir(current_dir) if os.path.isfile(os.path.join(current_dir, f))]  # 获取当前目录下的所有文件
 
    image_features = {}
    deleted_count = 0  # 记录删除的图片数量
    duplicate_pairs = []  # 用于保存重复图片的文件名对
 
    for file_name in files:
        if file_name.endswith('.jpg') or file_name.endswith('.png'):  # 筛选出图片文件
            file_path = os.path.join(current_dir, file_name)
            image_feature = extract_image_features(file_path)
 
            is_duplicate = False
            for existing_path, existing_feature in image_features.items():
                distance = np.linalg.norm(existing_feature - image_feature)  # 计算欧氏距离
                if distance &lt; 0.3:  # 设定阈值来判断相似度，根据实际情况调整
                    is_duplicate = True
                    print(f'删除重复图片: {file_path}')
                    os.remove(file_path)
                    deleted_count += 1
                    # 记录重复的文件名对 (当前文件名和已有文件名)
                    duplicate_pairs.append((file_name, os.path.basename(existing_path)))
                    break
 
            if not is_duplicate:
                image_features[file_path] = image_feature
 
    # 将重复图片文件名对保存到txt文件
    if duplicate_pairs:
        with open('duplicate_images.txt', 'w') as f:
            for file1, file2 in duplicate_pairs:
                f.write(f'{file1} 与 {file2} 重复\n')
    
    print('已删除 {} 张重复图片'.format(deleted_count))
 
# 加载预训练的ResNet50模型
model = ResNet50(weights='imagenet', include_top=False, pooling='avg')
 
delete_duplicate_images()
```。</description><guid isPermaLink="true">https://blog.cpuck.com/post/shan-chu-zhong-fu-tu-xiang.html</guid><pubDate>Sun, 20 Jul 2025 04:43:13 +0000</pubDate></item><item><title>md5处理文件</title><link>https://blog.cpuck.com/post/md5-chu-li-wen-jian.html</link><description>## 删除MD5值相同的文件

通过MD5值把重复的文件移到del文件夹，表格记录。</description><guid isPermaLink="true">https://blog.cpuck.com/post/md5-chu-li-wen-jian.html</guid><pubDate>Sun, 20 Jul 2025 04:42:26 +0000</pubDate></item><item><title>同步代码</title><link>https://blog.cpuck.com/post/tong-bu-dai-ma.html</link><description>## 常用的 Git 命令

更新端口刷新DNS

```
git config --global http.proxy 127.0.0.1:7890
git config --global https.proxy 127.0.0.1:7890
ipconfig/flushdns
```
### 代码仓库拉取推送

- https://github.com/settings/ssh/new
- https://huggingface.co/settings/keys/add?type=ssh

拉取仓库本地到本地推送到远程仓库

```
git clone https://github.com/lllyasviel/Fooocus.git
git config --global user.email 'you@example.com'
git config --global user.name 'Your Name'
git remote set-url origin git@github.com:lllyasviel/Fooocus.git
ssh-keygen -t rsa -b 4096 -C 'your_email@example.com'
ssh -T git@github.com
git add . 
git commit -m 'Test' 
```

本地推送到远程仓库
```
git push origin main
```
远程仓库同步到本地 
```
git pull origin main  
```

### 1. **克隆远程仓库**

克隆一个远程仓库到本地，命令如下：

```bash
git clone https://github.com/lllyasviel/Fooocus.git
```

### 2. **检查当前 Git 配置**

查看 Git 的全局配置，如用户名和邮箱：

```bash
git config --list
```

### 3. **检查当前状态**

查看当前工作目录和暂存区的状态（哪些文件已修改、未跟踪等）：

```bash
git status
```

### 4. **添加文件到暂存区**

将文件添加到暂存区，准备提交：

```bash
git add &lt;file_name&gt;  # 添加指定文件
git add .  # 添加所有修改的文件
```

### 5. **提交更改**

提交更改并添加提交信息：

```bash
git commit -m '描述本次提交的内容'
```

### 6. **推送远程仓库**

将本地更改推送到远程仓库：

```bash
git push origin branch-name
```

### 7. **远程仓库更新**

拉取远程仓库的更新，并合并到当前分支：

```bash
git pull origin branch-name
```

### 8. **查看远程仓库信息**

查看当前项目的远程仓库地址：

```bash
git remote -v
```

### 9. **查看提交历史**

查看提交历史记录：

```bash
git log
```

### 10. **创建新分支**

创建一个新分支，并切换到该分支：

```bash
git checkout -b new-branch-name
```

### 11. **切换分支**

切换到已有的分支：

```bash
git checkout branch-name
```

### 12. **合并分支**

将当前分支合并到目标分支：

```bash
git merge branch-name
```。</description><guid isPermaLink="true">https://blog.cpuck.com/post/tong-bu-dai-ma.html</guid><pubDate>Sun, 20 Jul 2025 04:41:37 +0000</pubDate></item><item><title>查找代码</title><link>https://blog.cpuck.com/post/cha-zhao-dai-ma.html</link><description>## Windows 查找
```
Get-ChildItem -Recurse -File | Select-String -Pattern '56'
```
## Bash 查找
搜索匹配当前目录下所有文件名或文件里的内容打印显示行号
```
grep -rn 'Money' *
```
搜索多个文件并查找匹配文本在哪些文件中：
```
grep -l 'Money' file1 file2 file3...
```
查找 formatting.php 文件内 length’, 55 替换 length’, 56 :

```
sed -i s/'length', 55'/'length', 56'/g `grep 'length', 55' -rl --include='formatting.php' ./`
```。</description><guid isPermaLink="true">https://blog.cpuck.com/post/cha-zhao-dai-ma.html</guid><pubDate>Sun, 20 Jul 2025 04:40:46 +0000</pubDate></item><item><title>NextChat</title><link>https://blog.cpuck.com/post/NextChat.html</link><description>

✨ Light and Fast AI Assistant,with Claude, DeepSeek, GPT4 &amp; Gemini Pro support. 


[NextChatAI](https://nextchat.club?utm_source=readme) / [Web App Demo](https://app.nextchat.dev) / [Desktop App](https://github.com/Yidadaa/ChatGPT-Next-Web/releases) / [Discord](https://discord.gg/YCkeafCafC) / [Enterprise Edition](#enterprise-edition) / [Twitter](https://twitter.com/NextChatDev)


[saas-url]: https://nextchat.club?utm_source=readme
[saas-image]: https://img.shields.io/badge/NextChat-Saas-green?logo=microsoftedge
[web-url]: https://app.nextchat.dev/
[download-url]: https://github.com/Yidadaa/ChatGPT-Next-Web/releases
[Web-image]: https://img.shields.io/badge/Web-PWA-orange?logo=microsoftedge
[Windows-image]: https://img.shields.io/badge/-Windows-blue?logo=windows
[MacOS-image]: https://img.shields.io/badge/-MacOS-black?logo=apple
[Linux-image]: https://img.shields.io/badge/-Linux-333?logo=ubuntu

[&lt;img src='https://zeabur.com/button.svg' alt='Deploy on Zeabur' height='30'&gt;](https://zeabur.com/templates/ZBUEFA) [&lt;img src='https://vercel.com/button' alt='Deploy on Vercel' height='30'&gt;](https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2FChatGPTNextWeb%2FChatGPT-Next-Web&amp;env=OPENAI_API_KEY&amp;env=CODE&amp;project-name=nextchat&amp;repository-name=NextChat)  [&lt;img src='https://gitpod.io/button/open-in-gitpod.svg' alt='Open in Gitpod' height='30'&gt;](https://gitpod.io/#https://github.com/ChatGPTNextWeb/NextChat) 

[&lt;img src='https://github.com/user-attachments/assets/903482d4-3e87-4134-9af1-f2588fa90659' height='50' width='' &gt;](https://monica.im/?utm=nxcrp)



## Dokploy

Dokploy 是一个免费的、可自托管的平台即服务 （PaaS），可简化应用程序和数据库的部署和管理。</description><guid isPermaLink="true">https://blog.cpuck.com/post/NextChat.html</guid><pubDate>Sat, 19 Jul 2025 20:47:38 +0000</pubDate></item><item><title>创建博客</title><link>https://blog.cpuck.com/post/chuang-jian-bo-ke.html</link><description>## 安装步骤

1. 【创建仓库】点击[通过模板创建仓库](https://github.com/new?template_name=Gmeek-template&amp;template_owner=Meekdai)，建议仓库名称为`XXX.github.io`，其中`XXX`为你的github用户名。</description><guid isPermaLink="true">https://blog.cpuck.com/post/chuang-jian-bo-ke.html</guid><pubDate>Sat, 19 Jul 2025 17:50:50 +0000</pubDate></item></channel></rss>